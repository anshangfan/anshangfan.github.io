[{"title":"mysql基本操作","date":"2018-03-13T16:41:59.000Z","path":"2018/03/14/mysql基本操作/","text":"登陆1mysql -uroot -p 登录本机服务器，连接3306端口 12mysql -uroot -p -hXXX.XXX.XX.XXX -p3306登陆指定ip的数据库服务器,端口号是3306， 若端口是3306，后面的-p3306可以不写 查看数据库 12show databases；show schemas； 进入数据库 1use 数据库名称; 查看数据表 1show tables; 退出客户端 12quit;\\q mysql用户mysql用户用 用户名@网络地址 来标识例如 ‘root‘@’localhost’ ‘root‘@’192.168.122.8’ ‘root‘@’192.168.122.%’任意102.168.122网段的用户都可以访问 ‘root‘@’%’任意用户可登陆用户授权: 可以设置一个用户访问数据库的权限,比如允许访问哪些库,哪些表,哪些字段 让root用户可以在远程连接,需要两步: ​ 1.创建用户 12345678910111213create user 'abc'@'localhost' identified by '123456' 创建一个叫abc的本地用户, 用123456 的密码登陆 create user 'abc'@'192.168.111.2' identified by '' 创建一个abc用户,在192.168.111.2网端登陆,无密码登陆 ​ 2.对用户授权 12grant all 授予所有权限on *.* to 用户名 中文问题数据库储存的字符编码,与客户端字符编码可能不一致 1234567GBK 国标码 一篇文章,只用中文 中文字符 占两个字节UTF-8 支持全球范围所有编码 若要在一篇文章显示很多国家文字,则可以用utf-8 中文字符 占三个字节 服务器要做正确的编码转换,就必须知道客户端发送的是什么编码 windows 字符行的字符编码就是gbk编码 12通知服务器,客户端的编码是gbkset names gbk; 数据库的管理创建数据库 12create database 数据库名称;charset=utf-8; 指定utf-8编码,用于保存中文数据,防止乱码 查看数据库 1234方法一:show databases;方法二:show create database 数据库名\\G 查看某个数据库创建的sql语句 ;和\\G结尾的区别 设有a ,b 两字段 a:1,2 b:3,4 ;结尾显示 1234a b--- ---1 32 4 \\G结尾 1234**********1************a:1 b:3**********2************a:2 b:4 修改数据库 只能修改数据库的默认字节编码 123alter database 数据库名;charset gbk;show create database 数据库名\\G 删除数据库 所有的表、数据都会被删除,不可恢复 1drop database 数据库名; 表的操作创建表123create table 表名(列名 数据类型, //列名之间加 , 隔开 primary key 主键 not null 非空 auto_increment自增 foreign key (列名) references UserTable(列名) 外键)charset=utf-8;engine=innodb; 较为常用的engine存储引擎 innodb (默认引擎) 、myisam 修改表改表名 1rename table 原表名 to 想要改的名字; 改表属性 123456修改存储引擎: alter table 表名 engine=myisam;修改字符编码: alter table 表名 charset=utf-8; 添加字段 1alter table 表名 add 列名 数据类型 first(把这列放在最前面) 改字段名 12alter table 表名change 原列名 现在要改的 数据类型 ; 改字段类型 12alter table 表名modify 列名 原数据类型 想改的数据类型 ; 改字段顺序 12alter table 表名modify 列名 after/first 列名; 删除字段 123删除字段所有的数据也会被删除,不可恢复alter table 表名drop column 列名; 查看表123456方法一:show tables;方法二:desc 表名; //查看表结构方法三:show create table 表名\\G 删除表会删除表中所有数据,不可恢复 1drop table if exists 表名; 截断表按照原结构删除表并重新创建,两步合成一步执行 1truncate table 表名; SQL语句结构化的查询语言(Structured Query Language) DDL​ 数据定义语言 ​ 建库建表 DML​ 数据操作语言 ​ 增删改 DQL​ 数据查询语言 ​ select insert 插入数据123456789use 数据库名;create table 表名( id int, name varchar(20))engine=innodb charset=utf-8; //创建表set names gbk;//通知服务器,客户端使用的是什么编码insert into 表名 values(1,'张三');也可以插入多条数据insert into 表名 values(2,'李四'),(3,'王五'),(4,'赵六'); update 修改数据1update 表名 set 列名= ,列名= where 列名= ;//不写where的话所有数据都被更改 delete 删除数据1delect from 表名 where 列名= ;//不加where删除这个表内所有数据 select 查询数据12select * from 表名; 查询这个表内所有数据select 列名 from 表名;查询这个表内 这个列的所有数据 技术术语database mysql中的数据库 schema mysql中的数据库 table 表 row 一行数据 record 一行记录(数据) column 一列数据 field 一列字段(数据) 存储引擎innodb (默认的)​ 支持事物 ​ 支持外键 ​ 支持行级锁 两个客户端同时连接数据库,你若在修改某条数据时,另一人无法访问这条数据 ​ 有较多修改操作的表 myisam​ 不支持事物 ​ 不支持外键 ​ 只有表级锁 操作一行数据的时候,锁定整张表,其他人无法访问这张表 ​ 大量查询,很少修改的表,可以使用myisam ,这样查询效率更高 memory​ 内存表 ​ 数据库重启,数据全部丢失,无法保存到磁盘 定长字符串char(20)123456789定长20个字符 不足20个字符,补空格 超过20个字符,可能出错或截断 最大长度,不能超过255个字符 所有该字段的字符串数据,都是连续存储 varchar(20)123456789变长字符串 最长不能超过20个字符 不足20个字符,直接存储 超出20个字符,可能出错或截断存储的最大字节量,不能超过65535 设置成GBK编码的话,字符数为65525/2 有余数舍弃 设置成utf-8编码的话,字符数为65535/3字节量&lt;=255,需要一个额外的字节,表示字符串的字节长度字节量&gt;255,需要两个额外字节,表示字符串的字节长度 char 和 varchar​ char类型效率更高,定长字符串尽量使用char类型 text​ 最大存储65535字节的字符串 ​ 一般存储长的文本使用text 数字整数类型tinyint​ 1字节 -128-127 smallint​ 2字节 int​ 4字节 ​ int(3) 3表示位数 bigint​ 8字节 浮点类型float​ 4字节 精度低 double​ 8字节 精度高 定点数decimal​ 使用的时候是decimal(m,n) ​ 一共m位,小数位n位 ​ 浮点数运算可能会产生不精确的结果 ​ 表示金额一般使用decimal unsigned 无符号,只有正数 zerofill ​ 用0填充配合int(6)格式设置使用 ​ 1234—–&gt; 001234 ​ 12 ——&gt; 000012 日期datetime​ 年月日时分秒 ​ 时间范围 ​ 9999年12月31 data​ 年月日 time​ 时分秒 timestamp​ 年月日时分秒 ​ 时间戳 ​ 修改一行数据时,第一个timestamp字段,会 自动更新成成系统当前时间 ​ 时间范围 ​ 最大只能到2037年 ​ 不足20个字符,补空格 ​ 超过20个字符,可能出错或截断 ​ 最大长度,不能超过255个字符 ​ 所有该字段的字符串数据,都是连续存储","tags":[{"name":"mysql","slug":"mysql","permalink":"http://anshangfan.github.io/tags/mysql/"}]},{"title":"Java复制数组的集中方法","date":"2018-03-12T03:06:17.000Z","path":"2018/03/12/java复制数组的几种方法/","text":"JAVA语言的下面几种数组复制方法中，哪个效率最高？ A.for循环逐一复制B.System.arraycopyC.System.copyofD.使用clone方法 效率：System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环 1、System.arraycopy的用法： 12345public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 参数： src - 源数组。 srcPos - 源数组中的起始位置。 dest - 目标数组。 destPos - 目标数据中的起始位置。 length - 要复制的数组元素的数量 应用实例： 1234567891011121314public class Main&#123; public static void main(String[] args) &#123; int[] a1=&#123;1,2,3,4,5,6&#125;; int[] a2=&#123;11,12,13,14,15,16&#125;; System.arraycopy(a1, 2, a2, 3, 2); System.out.print(\"copy后结果：\"); for(int i=0;i&lt;a2.length;i++)&#123; System.out.print(a2[i]+\" \"); &#125;&#125;&#125; 运行结果： 2、clone 的用法： java.lang.Object类的clone()方法为protected类型，不可直接调用，需要先对要克隆的类进行下列操作： 首先被克隆的类实现Cloneable接口；然后在该类中覆盖clone()方法，并且在该clone()方法中调用super.clone()；这样，super.clone()便可以调用java.lang.Object类的clone()方法。 应用实例： 12345678910111213141516171819202122232425//被克隆的类要实现Cloneable接口class Cat implements Cloneable &#123; private String name; private int age; public Cat(String name,int age) &#123; this.name=name; this.age=age; &#125; //重写clone()方法 protected Object clone()throws CloneNotSupportedException&#123; return super.clone() ; &#125;&#125;public class Clone &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Cat cat1=new Cat(\"xiaohua\",3); System.out.println(cat1); //调用clone方法 Cat cat2=(Cat)cat1.clone(); System.out.println(cat2); &#125;&#125; 3、复制引用和复制对象的区别 复制引用：是指将某个对象的地址复制，所以复制后的对象副本的地址和源对象相同，这样，当改变副本的某个值后，源对象值也被改变； 复制对象：是将源对象整个复制，对象副本和源对象的地址并不相同，当改变副本的某个值后，源对象值不会改变； 1234567Cat cat1=new Cat(\"xiaohua\",3);//源对象 System.out.println(\"源对象地址\"+cat1); //调用clone方法，复制对象 Cat cat2=(Cat)cat1.clone(); Cat cat3=(Cat)cat1;//复制引用 System.out.println(\"复制对象地址：\"+cat2); System.out.println(\"复制引用地址：\"+cat3); 输出结果： 4、Arrays.copyOf 的用法： 这个方式必须明确自行新建立一个数组对象。在JDK 6中，Arrays 类别 新增了copyOf()方法，可以直接传回一个新的数组对象，而当中包括复制的内容，例如： 1234567891011import java.util.Arrays;public class ArrayDemo &#123;public static void main(String[] args) &#123;int[] arr1 = &#123;1, 2, 3, 4, 5&#125;; int[] arr2 = Arrays.copyOf(arr1, arr1.length);for(int i = 0; i &lt; arr2.length; i++) System.out.print(arr2[i] + \" \"); System.out.println();&#125;&#125; 执行结果： 11 2 3 4 5 Arrays的copyOf()方法传回的数组是新的数组对象，所以您改变传回数组中的元素值，也不会影响原来的数组。 copyOf()的第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值，例如： 1234567891011import java.util.Arrays;public class ArrayDemo &#123;public static void main(String[] args) &#123;int[] arr1 = &#123;1, 2, 3, 4, 5&#125;; int[] arr2 = Arrays.copyOf(arr1, 10);for(int i = 0; i &lt; arr2.length; i++) System.out.print(arr2[i] + \" \"); System.out.println();&#125;&#125; 执行结果： 11 2 3 4 5 0 0 0 0 0","tags":[{"name":"java","slug":"java","permalink":"http://anshangfan.github.io/tags/java/"}]},{"title":"hexo写博文时插入图片","date":"2018-03-11T02:52:31.000Z","path":"2018/03/11/hexo写博文时插入图片/","text":"本人试着在写博客的时候插入图片，用的是Typora软件写的，写的时候插入图片很方便，但在最后上传至git上后，发现图片无法正常显示，特意搜索了一下之后，将成功的方法总结如下： first1 把主页配置文件_config.yml 里 1`post_asset_folder:`这个选项设置为`true` 2 在你的hexo目录下执行这样一句话 1`npm install hexo-asset-image --save` 3 等待一小段时间后，再运行 1`hexo n \"xxxx\"` 来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 second在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。","tags":[{"name":"博客","slug":"博客","permalink":"http://anshangfan.github.io/tags/博客/"}]},{"title":"hadoop集群搭建","date":"2018-03-10T15:45:24.000Z","path":"2018/03/10/hadoop集群搭建/","text":"hadoop-env.sh 、yarn-env.sh 、mapred-env.sh 三个文件中将JAVA_HOME路径改为/opt/modules/jdk1.7.0_80（你自己的java保存路径） core-site.xml在中加入 1234567891011121314&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://当前登录的主机名:8020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/modules/hadoop-2.6.5/tmp&lt;/value&gt; &lt;/property&gt; hdfs-site.xml 在中加入 123456789101112131415&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;当前登录的主机名:50090&lt;/value&gt; &lt;/property&gt; mapred-site.xml在中加入 1234567&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; Slaves 中 将localhost改为当前登录的主机名 yarn-site.xml在中加入 1234567891011121314&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;当前登录的主机名&lt;/value&gt;&lt;/property&gt; 在hadoop-2.6.5 目录下创建tmp文件 1mkdir tmp 在该目录下输入 1bin/hdfsnamenode –format 运行成功后输入 1sbin/start-dfs.sh 运行后输入 jps 若出现 1234567JpsNamenodeSecondarynamenodeDatanode 四个文件即成功 此时在浏览器中输入 1主机地址：50070 是否出现 出现即成功 在该目录下输入 1sbin/start-yarn.sh 成功运行后在浏览器中输入 1主机地址：8088 出现 就成功","tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://anshangfan.github.io/tags/hadoop/"}]},{"title":"虚拟机环境配置","date":"2018-03-10T15:26:45.000Z","path":"2018/03/10/虚拟机环境配置/","text":"给管理员权限 12345su rootsudo vi /etc/sudoers添加 Hadoop ALL=(ALL) ALL 关闭计算机防火墙 123先用serviceiptables stop 暂时关闭再用 chkconfigiptables off 永久关闭 查看关于java的安装文件 1sudo rpm –qa|grep java 卸载软件 1sudo rpm -e --nodeps 文件1 文件2 ….. 查看当前目录 pwd 显示当前目录中的内容 ls 在opt目录下安装jdk 12Softwares存放上传的软件 sudo mkdir softwaresModules 存放执行的文件 进入softwares目录，用sudo mv +~/+文件名 + . 将需要的文件移动到当前目录下 将压缩包解压至 modules文件下 sudo tar -zxvf +文件名 -C ../ modules/ 配置java环境变量 123456789 vi./.bash_profile 进入文件后输入以下内容# Java_Configurationexport JAVA_HOME=/opt/modules/jdk1.7.0_80export PATH=PATH:JAVA_HOME/bin保存后运行文件Source .bash_profile SSH免登陆 ​ 开启ssh免登陆 1sudo vi /etc/ssh/sshd_config ​ 生成ssh免登陆的公钥和密钥 1ssh-keygen –t rsa ​ 查看隐藏文件 1ls -al ​ 保存公钥到authorized_keys文件中 1catid_rsa.pub &gt;&gt;authorized_keys ​ 对.ssh目录和authorized_keys进行授权 1234cd .ssh/sudo chmod 600 authorized_keyscd ..sudo chmod 750 .ssh ​ 设置主机名对应的ip 123sudo vi /etc/hosts输入ip地址 主机名 ​ 测试 1ssh 主机名 更改opt文件下的属主，属组 1sudo chown –R hadoop(用户名)：hadoop /opt","tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://anshangfan.github.io/tags/hadoop/"}]},{"title":"辛德勒名单","date":"2018-03-08T18:06:32.000Z","path":"2018/03/09/辛德勒名单/","text":"​ 昨天晚上突然很想找部电影看，在网上搜索，最后看到了《辛德勒的名单》。​ 初中的时候就听说过这部电影，那是在一节音乐课上，老师给我们放电影里的一段音乐，配着小段电影情节：辛德勒和他的夫人骑着马在高处看着德国人血洗犹太人区，无数人被残忍杀害，还有一些人正排着队往可能安全的范围里走。在队伍外面，一个穿红裙子的小女孩儿自顾自走着，她走过士兵，穿过犹太人群，在血腥和恐惧中径自走着。没有一个士兵发现她，犹太人看到她也没有去打扰她。她走着，红色的衣服使他在灰黑色的背景中那么扎眼。​ 我想到了南京大屠杀。日本人到中国，他是作为一个胜利者来的。在那时的日本人眼里，中国人就像是德国兵眼中的犹太人一样，是他们的俘虏，而俘虏，不是人。​ 电影中多次出现了“名单”这个词，德国人的名单一出现就意味着又会有一批犹太人被杀死，而他们筛选犹太人的方式是我难以想象的。脱光衣服，男人女人在一起一丝不挂地绕着圈跑，身强体壮的活，老弱病残的死。一些女人为了自己看上去健康一点，就用针扎破手指用鲜血给自己画腮。当被选中留下来时她们拥抱在一起万分庆幸。她们又可以活一阵子了，尽管生不如死，但是“留得青山在，不怕没柴烧”。​ 发生在我们国家的南京大屠杀，活埋，杀人比赛，毒气实验，奸淫妇女……何其相似！​ 我竟然想，是不是所有的战争都有这样的结局：胜利者耀武扬威，掌握着失败者的生杀大权，掌握着人的尊严；失败者任人宰割，忍气吞声，命贱如畜生？​ 可是，战争结果是胜利或失败，怎么会把人性也改变了？是不是可以说，赢为兽，输为畜！那人呢？人性在哪里？​ 错的不是我，也不是你，更不是他，错的不是个人，不是国家，错的，是世界，是战争。然而，我又分明从中看到了伟大的鲜明的人性。辛德勒从一心办工厂到竭尽所能保护犹太人，从只知赚钱到付出所有财产救下一千一百个犹太人。这难道不是人性吗？辛德勒最后成为了一个至善的人，直到多年以后仍旧受人尊敬，在电影最后，被拯救的犹太人一个个的在辛德勒的墓前献上敬意，我甚至感动的落了泪。这是人性的光辉，甚至可以说这是人性的至高点。​ 那么我们人的善良究竟沒有丧失。 ​ 人性。何谓人性？​ 善性是人性，那恶性也必然是人性的一面。​ 战争之所以错，就是因为他激发了太多的人性之恶，或者，与其说是激发，不如说是释放，是发泄。而这释放这发泄，是多么的可怕。​ 以前自己从未想过战争到底有多残酷，国际形式紧张，也并未引起我多大的恐惧，但现在，我祈 祷和平，反对战争。​ 愿人性多流露一些善，少需要一些恶。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://anshangfan.github.io/tags/随笔/"}]},{"title":"Java中计算程序运行耗时的方法比较","date":"2018-03-08T07:10:44.000Z","path":"2018/03/08/Java中计算程序运行耗时的方法对比/","text":"Java中测试程序代码运行时间的方式有两种： 第一种：以毫秒为单位计算的。 1long startTime=System.currentTimeMillis(); //下面是一些测试代码 1234567891011long startTime=System.currentTimeMillis();for(int i=0;i&lt;10000;i++)&#123;System.out.println(\"当前是：\"+i);&#125;long endTime=System.currentTimeMillis();System.out.println(\"当前程序耗时：\"+（endTime-startTime）+\"ms\"); 第二种：以纳秒为单位计算的。 1long startTime=System.nanoTime(); //下面是一些测试代码 1234567891011long startTime=System.nanoTime();for(int i=0;i&lt;10000;i++)&#123;System.out.println(\"当前是：\"+i);&#125;long endTime=System.nanoTime();System.out.println(\"当前程序耗时：\"+（endTime-startTime）+\"ns\"); 测试程序如果需要高精确时间，一般会选择第二种， 测试程序如果需要一般精确时间，一般会选择第一种， 时间换算： 1小时=60分钟 1分钟=60秒 1秒=1000毫秒 1毫秒=1000微秒 1微秒=1000纳秒 1纳秒=1000皮秒","tags":[{"name":"java","slug":"java","permalink":"http://anshangfan.github.io/tags/java/"}]},{"title":"九九乘法表","date":"2018-03-07T03:04:53.000Z","path":"2018/03/07/九九乘法表/","text":"1.用for循环写 123456789101112public class multiplication&#123; public static void mian (String args[])&#123; for(int x=1;x&lt;10;x++) &#123; for(int y=1;y&lt;=x;y++) &#123; System.out.print(x+\"*\"+y+\"=\"+(x*y)+\"\\t\"); if (x==y) &#123; System.out.println(); &#125; &#125; &#125; &#125; &#125; 2.用while循环写 12345678910111213public class multiplication&#123; public static void main(String[] args) &#123; int x = 0; while (++x &lt; 10) &#123; int y = 0; while (++y &lt;= x) &#123; System.out.print(x + \"*\" + y + \"=\" + (x*y) + \"\\t\"); &#125; System.out.println(); &#125; &#125; &#125; 3.用do….while循环写 123456789101112131415public class multiplication &#123; public static void main(String[] args) &#123; int x=1,y=1; do&#123; y=1; System.out.println(); do&#123; System.out.print(\" \"+y+\"*\"+x+\"=\"+(x*y)); y++; &#125; while(y&lt;=x); x++; &#125; while(x&lt;10); &#125; &#125;","tags":[{"name":"java","slug":"java","permalink":"http://anshangfan.github.io/tags/java/"}]},{"title":"用hexo在github上创建博客（mac版）","date":"2018-03-06T17:33:07.000Z","path":"2018/03/07/用hexo在github上创建博客（mac版）/","text":"1.下载安装nodejs 12 检查是否安装完成：node -v 2.下载安装git 12 检查是否成功安装： git —-version 3.打开终端 输入 sudu npm install -g hexo 安装hexo 12 若失败则用以下语句sudo npm install --unsafe-perm --verbose -g hexo 4.创建一个文件夹，取名 blog 1终端中可输入 mkdir blog 5.在终端进入文件夹blog目录 12输入 hexo init 初始化博客输入 hexo s 将给的网址在浏览器中打开，会发现有一个博客框架 ，终端中用ctrl +c退出 6.github配置 123456789​ 1.注册github账号，并登陆​ 2.获取本机的ssh口令 在终端输入 git config --global user.name “github用户名” git config --global user.email “github邮箱” ssh-keygen -t rsa -C “github邮箱”​ 3.将生成的id_rsa.pub文件内容复制​ 4.复制的内容添加到github上的ssh内 5.创建新库 将二级域名改为 用户名.github.io格式 7.在blog文件夹下的_config.yml做如下修改 1234type: gitrepository: 写自己库的地址brach: master注意： 冒号后面要保留一个空格，不然运行会报错 8.在终端上传博客 12341.输入 npm install hexo-deployer-git –save2.输入 hexo g 生成静态文件 3.hexo s 启动服务器(本地服务器)通常网址为http://localhost:4000/ 可在该网址查看效果4.hexo d 文件生成 后立即部署网站 至此，一个简单的博客就搭建完成了！","tags":[{"name":"博客","slug":"博客","permalink":"http://anshangfan.github.io/tags/博客/"}]},{"title":"Hello World","date":"2018-03-06T16:36:25.000Z","path":"2018/03/07/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"博客","slug":"博客","permalink":"http://anshangfan.github.io/tags/博客/"}]}]